// Generated by CoffeeScript 1.4.0
(function() {
  var Node, Tree, remove, root, sanitizeId, unique,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.Tree = Tree = (function() {

    function Tree() {
      this.nodes = [];
      this.root = null;
    }

    Tree.prototype.createNode = function(value, identifier, parent) {
      var node;
      node = new Node(value, identifier);
      if (!(parent != null)) {
        if (this.root != null) {
          throw 'Cannot have multiple root nodes.';
        } else {
          this.root = node.identifier;
        }
      }
      this.nodes.push(node);
      this._updateFPointer(parent, node.identifier, 'ADD');
      if (parent != null) {
        node.bPointer = sanitizeId(parent);
        node.level = this.nodes[this._getIndex(parent)].level + 1;
      } else {
        node.level = 0;
      }
      return node;
    };

    Tree.prototype.expand = function(position, mode, filter) {
      var expansion, queue, results;
      if (position == null) {
        position = this.root;
      }
      if (mode == null) {
        mode = 'DEPTH';
      }
      filter || (filter = function() {
        return true;
      });
      results = [];
      if (filter(position)) {
        results.push(position);
        queue = this.nodes[this._getIndex(position)].fPointer;
        while (queue.length) {
          if (filter(queue[0])) {
            results.push(queue[0]);
            expansion = this.nodes[this._getIndex(queue[0])].fPointer;
            if (mode === 'DEPTH') {
              queue = expansion.concat(queue.slice(1));
            } else if (mode === 'WIDTH') {
              queue = queue.slice(1).concat(expansion);
            }
          } else {
            queue = queue.slice(1);
          }
        }
      }
      return results;
    };

    Tree.prototype._getIndex = function(position) {
      var index, node, _i, _len, _ref;
      _ref = this.nodes;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        node = _ref[index];
        if (node.identifier === position) {
          break;
        }
      }
      return index;
    };

    Tree.prototype.getNodeLevel = function(identifier) {
      return this.nodes[this._getIndex(identifier)].level;
    };

    Tree.prototype.getNodeValue = function(identifier) {
      return this.nodes[this._getIndex(identifier)].value;
    };

    Tree.prototype.isAncestor = function(identifier, child) {
      var ancestors;
      ancestors = this.reverse(child);
      return __indexOf.call(ancestors, identifier) >= 0 && child !== identifier;
    };

    Tree.prototype.isChild = function(identifier, parent) {
      return this.isParent(parent, identifier);
    };

    Tree.prototype.isDescendant = function(identifier, parent) {
      return this.isAncestor(parent, identifier);
    };

    Tree.prototype.isParent = function(identifier, child) {
      return identifier === this.nodes[this._getIndex(child)].bPointer;
    };

    Tree.prototype.moveNode = function(node, destinationParent) {
      var parent;
      parent = this.nodes[this._getIndex(node)].bPointer;
      this._updateFPointer(parent, node, 'DELETE');
      this._updateFPointer(destinationParent, node, 'ADD');
      return this._updateBPointer(node, destinationParent);
    };

    Tree.prototype.removeNode = function(identifier, clearChildren) {
      var currentNode, id, parent, _i, _j, _len, _len1, _ref, _ref1;
      if (clearChildren == null) {
        clearChildren = true;
      }
      currentNode = this.nodes[this._getIndex(identifier)];
      if (!(currentNode != null)) {
        throw 'Attempting to delete a node that does not exist.';
      }
      parent = currentNode.bPointer;
      if (clearChildren) {
        _ref = this.expand(identifier);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          id = _ref[_i];
          this.nodes = remove(this.nodes, this.nodes[this._getIndex(id)]);
        }
      } else {
        _ref1 = currentNode.fPointer;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          id = _ref1[_j];
          this.moveNode(id, parent);
        }
        this.nodes = remove(this.nodes, currentNode);
      }
      return this._updateFPointer(parent, identifier, 'DELETE');
    };

    Tree.prototype.reverse = function(position, filter) {
      var current, results;
      filter || (filter = function() {
        return true;
      });
      current = position;
      results = [];
      while (current != null) {
        if (filter(current)) {
          results.push(current);
        }
        current = this.nodes[this._getIndex(current)].bPointer;
      }
      return results;
    };

    Tree.prototype.subTree = function(position) {
      var node, st, _i, _len, _ref;
      st = new Tree;
      st.root = position;
      _ref = this.expand(position);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        st.nodes.push(this.nodes[this._getIndex(node)]);
      }
      return st;
    };

    Tree.prototype.toObj = function(position, nodeKey, childrenKey) {
      var children, currentNode, element, queue, tree, _i, _len;
      if (position == null) {
        position = this.root;
      }
      if (nodeKey == null) {
        nodeKey = 'data';
      }
      if (childrenKey == null) {
        childrenKey = 'children';
      }
      currentNode = this.nodes[this._getIndex(position)];
      queue = currentNode.fPointer;
      tree = {};
      tree[nodeKey] = currentNode.value;
      children = [];
      for (_i = 0, _len = queue.length; _i < _len; _i++) {
        element = queue[_i];
        children = children.concat(this.toObj(element, nodeKey, childrenKey));
      }
      if (children.length) {
        tree[childrenKey] = children;
      }
      return tree;
    };

    Tree.prototype.transplant = function(destinationParent, newTree) {
      var allNodes, identifiers, index, node;
      allNodes = this.nodes.concat(newTree.nodes);
      identifiers = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = allNodes.length; _i < _len; _i++) {
          node = allNodes[_i];
          _results.push(node.identifier);
        }
        return _results;
      })();
      if (identifiers.length !== unique(identifiers).length) {
        throw 'Cannot have duplicate nodes.';
      }
      if (destinationParent != null) {
        index = newTree._getIndex(newTree.root);
        newTree.nodes[index].bPointer = sanitizeId(destinationParent);
      }
      this._updateFPointer(destinationParent, newTree.root, 'ADD');
      return this.nodes = this.nodes.concat(newTree.nodes);
    };

    Tree.prototype._updateBPointer = function(position, identifier) {
      if (identifier != null) {
        return this.nodes[this._getIndex(position)].bPointer = sanitizeId(identifier);
      }
    };

    Tree.prototype._updateFPointer = function(position, identifier, mode) {
      if (position) {
        return this.nodes[this._getIndex(position)].updateFPointer(identifier, mode);
      }
    };

    return Tree;

  })();

  root.Node = Node = (function() {

    function Node(value, identifier) {
      this.value = value;
      this.identifier = identifier ? sanitizeId(identifier) : this.generateUUID();
      this.bPointer = null;
      this.fPointer = [];
      this.level = null;
    }

    Node.prototype.generateUUID = function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r, v;
        r = Math.random() * 16 | 0;
        v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    };

    Node.prototype.updateFPointer = function(identifier, mode) {
      if (mode == null) {
        mode = 'ADD';
      }
      if (mode === 'ADD') {
        return this.fPointer.push(sanitizeId(identifier));
      } else if (mode === 'DELETE') {
        return this.fPointer = remove(this.fPointer, sanitizeId(identifier));
      } else if (mode === 'REPLACE') {
        return this.fPointer = [sanitizeId(identifier)];
      }
    };

    return Node;

  })();

  remove = function(arr, val) {
    var x, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      x = arr[_i];
      if (x !== val) {
        _results.push(x);
      }
    }
    return _results;
  };

  sanitizeId = function(id) {
    return id.split(' ').join('');
  };

  unique = function(arr) {
    var i, key, obj, set;
    obj = {};
    set = [];
    i = arr.length;
    while (i--) {
      obj[arr[i]] = 1;
    }
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      set.push(key);
    }
    return set;
  };

}).call(this);
