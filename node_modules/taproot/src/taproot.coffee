root = exports ? this

root.Tree = class Tree
  constructor: ->
    @nodes = []
    @root = null

  # Creates a child node of the supplied parent node.  If no parent node is
  # specified, the node will serve as the root of the tree.
  createNode: (value, identifier, parent) ->
    node = new Node value, identifier

    if not parent?
      if @root?
        throw 'Cannot have multiple root nodes.'
      else
        @root = node.identifier

    @nodes.push node
    @_updateFPointer parent, node.identifier, 'ADD'
    if parent?
      node.bPointer = sanitizeId parent
      node.level = @nodes[@_getIndex parent].level + 1
    else
      node.level = 0

    node

  # Returns a list of tree identifiers starting at the supplied position.
  # Supported modes are 'DEPTH' for depth-first and 'WIDTH' for width-first
  # iteration.  A provided filter will be applied to the result list.
  expand: (position = @root, mode = 'DEPTH', filter) ->
    filter ||= ->
      return true

    results = []
    if filter position
      results.push position

      queue = @nodes[@_getIndex position].fPointer

      while queue.length
        if filter queue[0]
          results.push queue[0]

          expansion = @nodes[@_getIndex queue[0]].fPointer
          if mode is 'DEPTH'
            queue = expansion.concat queue[1..]
          else if mode is 'WIDTH'
            queue = queue[1..].concat expansion
        else
          queue = queue[1..]

    results

  # Gets the index of an identifier within the node collection.
  _getIndex: (position) ->
    for node, index in @nodes
      if node.identifier is position
        break
    index

  # Finds the node by the supplied identifier and returns its level.
  getNodeLevel: (identifier) ->
    @nodes[@_getIndex identifier].level

  # Finds the node by the supplied identifier and returns its value.
  getNodeValue: (identifier) ->
    @nodes[@_getIndex identifier].value

  # Checks whether the supplied node is an ancestor of the supplied child.
  isAncestor: (identifier, child) ->
    ancestors = @reverse child
    identifier in ancestors and child isnt identifier

  # Checks whether the supplied node is the direct child of the supplied parent.
  isChild: (identifier, parent) ->
    @isParent parent, identifier

  # Checks whether the supplied node is a descendant of the supplied parent.
  isDescendant: (identifier, parent) ->
    @isAncestor parent, identifier

  # Checks whether the supplied node is the direct parent of the supplied child.
  isParent: (identifier, child) ->
    identifier is @nodes[@_getIndex child].bPointer

  # Moves a node to become a child of the supplied destinationParent.
  moveNode: (node, destinationParent) ->
    parent = @nodes[@_getIndex node].bPointer
    @_updateFPointer parent, node, 'DELETE'
    @_updateFPointer destinationParent, node, 'ADD'
    @_updateBPointer node, destinationParent

  # Removes a node and (by default) all of its children.  If children are not
  # removed, they will become children of the removed node's parent.
  removeNode: (identifier, clearChildren = true) ->
    currentNode = @nodes[@_getIndex identifier]
    if not currentNode?
      throw 'Attempting to delete a node that does not exist.'

    parent = currentNode.bPointer
    if clearChildren
      for id in @expand identifier
        @nodes = remove @nodes, @nodes[@_getIndex id]
    else
      for id in currentNode.fPointer
        @moveNode id, parent
      @nodes = remove @nodes, currentNode

    @_updateFPointer parent, identifier, 'DELETE'

  # Returns a list of tree identifiers working backwards from the supplied
  # position.  A provided filter will be applied to the result list.
  reverse: (position, filter) ->
    filter ||= ->
      return true

    current = position

    results = []
    while current?
      if filter current
        results.push current
      current = @nodes[@_getIndex current].bPointer

    results

  # Returns a subtree using the supplied position as its root.
  subTree: (position) ->
    st = new Tree
    st.root = position
    for node in @expand position
      st.nodes.push(@nodes[@_getIndex node])
    st

  # Creates an object representation of the tree.
  toObj: (position = @root, nodeKey = 'data', childrenKey = 'children') ->
    currentNode = @nodes[@_getIndex position]
    queue = currentNode.fPointer
    tree = {}

    tree[nodeKey] = currentNode.value

    children = []
    for element in queue
      children = children.concat @toObj element, nodeKey, childrenKey

    if children.length
      tree[childrenKey] = children

    tree

  # Moves the root of the supplied newTree to a child node of the supplied
  # destinationParent.
  transplant: (destinationParent, newTree) ->
    allNodes = @nodes.concat(newTree.nodes)
    identifiers = (node.identifier for node in allNodes)
    if identifiers.length isnt unique(identifiers).length
      throw 'Cannot have duplicate nodes.'

    if destinationParent?
      index = newTree._getIndex newTree.root
      newTree.nodes[index].bPointer = sanitizeId destinationParent

    @_updateFPointer destinationParent, newTree.root, 'ADD'
    @nodes = @nodes.concat newTree.nodes

  # Sets a node's back pointer.
  _updateBPointer: (position, identifier) ->
    if identifier?
      @nodes[@_getIndex position].bPointer = sanitizeId identifier

  # Sets a node's forward pointer.
  _updateFPointer: (position, identifier, mode) ->
    if position
      @nodes[@_getIndex position].updateFPointer identifier, mode

root.Node = class Node
  constructor: (@value, identifier) ->
    @identifier = if identifier then sanitizeId identifier else @generateUUID()
    @bPointer = null
    @fPointer = []
    @level = null

  # Generates an rfc4122 version 4 compliant UUID.
  generateUUID: ->
    'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace /[xy]/g, (c) ->
      r = Math.random() * 16 | 0
      v = if c is 'x' then r else r & 0x3 | 0x8
      v.toString 16

  # Updates a node's forward pointer with respect to the supplied mode.
  # Possible modes are 'ADD', 'DELETE', and 'REPLACE'.
  updateFPointer: (identifier, mode = 'ADD') ->
    if mode is 'ADD'
      @fPointer.push sanitizeId identifier
    else if mode is 'DELETE'
      @fPointer = remove @fPointer, sanitizeId identifier
    else if mode is 'REPLACE'
      @fPointer = [sanitizeId identifier]

# Removes a value from an array.
remove = (arr, val) ->
  (x for x in arr when x isnt val)

# Removes spaces from a string.
sanitizeId = (id) ->
  id.split(' ').join('')

# Removes duplicate values from an array.
unique = (arr) ->
  obj = {}; set = []; i = arr.length

  while i--
    obj[arr[i]] = 1

  for own key of obj
    set.push key

  set
