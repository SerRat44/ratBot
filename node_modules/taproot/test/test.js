// Generated by CoffeeScript 1.4.0
(function() {
  var expect, taproot;

  expect = require('expect.js');

  taproot = require('../lib/taproot');

  describe('Tree', function() {
    describe('createNode', function() {
      it('should create a properly nested node within the tree', function() {
        var expected, nodes, tree;
        tree = new taproot.Tree;
        tree.createNode('root', 'root');
        tree.createNode('1st level', '1', 'root');
        tree.createNode('2nd level', '2', '1');
        tree.createNode('another 1st level', '1a', 'root');
        nodes = tree.toObj();
        expected = {
          data: 'root',
          children: [
            {
              data: '1st level',
              children: [
                {
                  data: '2nd level'
                }
              ]
            }, {
              data: 'another 1st level'
            }
          ]
        };
        return expect(nodes).to.eql(expected);
      });
      it('should not allow multiple root nodes', function() {
        var tree;
        tree = new taproot.Tree;
        tree.createNode();
        return expect(function() {
          return tree.createNode();
        }).to.throwError();
      });
      return it('should preserve arbitrary values', function() {
        var expected, nodes, tree;
        tree = new taproot.Tree;
        tree.createNode({
          test: 'me',
          please: 'ok'
        }, 'root');
        tree.createNode({
          also: 'this',
          check: [1, 3]
        }, '1st level', 'root');
        nodes = tree.toObj(tree.root, 'data');
        expected = {
          data: {
            test: 'me',
            please: 'ok'
          },
          children: [
            {
              data: {
                also: 'this',
                check: [1, 3]
              }
            }
          ]
        };
        return expect(nodes).to.eql(expected);
      });
    });
    describe('expand', function() {
      var tree;
      tree = new taproot.Tree;
      tree.createNode('root', 'root');
      tree.createNode('1st level', '1', 'root');
      tree.createNode('2nd level', '2', '1');
      tree.createNode('3rd level', '3', '2');
      tree.createNode('another 1st level', '1a', 'root');
      tree.createNode('another child', '3a', '1a');
      it('should return a list of identifiers in depth order when mode is DEPTH', function() {
        var expansion, expected;
        expansion = tree.expand();
        expected = ['root', '1', '2', '3', '1a', '3a'];
        return expect(expansion).to.eql(expected);
      });
      it('should return a list of identifiers in width order when mode is WIDTH', function() {
        var expansion, expected;
        expansion = tree.expand(tree.root, 'WIDTH');
        expected = ['root', '1', '1a', '2', '3a', '3'];
        return expect(expansion).to.eql(expected);
      });
      return it('should filter the results when a filter is provided', function() {
        var expansion;
        expansion = tree.expand(tree.root, 'DEPTH', function(elem) {
          return elem !== 'root';
        });
        return expect(expansion).to.be.empty();
      });
    });
    describe('getNodeLevel', function() {
      return it('should return the level of the specified node:', function() {
        var node, tree;
        tree = new taproot.Tree;
        tree.createNode('root', 'root');
        tree.createNode('1st level', '1', 'root');
        tree.createNode('2nd level', '2', '1');
        tree.createNode('3rd level', '3', '2');
        tree.createNode('another 1st level', '1a', 'root');
        tree.createNode('another child', '3a', '1a');
        node = tree.getNodeLevel('3a');
        expect(node).to.eql(2);
        node = tree.getNodeLevel('root');
        expect(node).to.eql(0);
        node = tree.getNodeLevel('3');
        expect(node).to.eql(3);
        node = tree.getNodeLevel('1');
        expect(node).to.eql(1);
        node = tree.getNodeLevel('1a');
        return expect(node).to.eql(1);
      });
    });
    describe('getNodeValue', function() {
      return it('should return the value of the specified node:', function() {
        var node, tree;
        tree = new taproot.Tree;
        tree.createNode('root', 'root');
        tree.createNode('1st level', '1', 'root');
        tree.createNode('2nd level', '2', '1');
        tree.createNode('3rd level', '3', '2');
        tree.createNode('another 1st level', '1a', 'root');
        tree.createNode('another child', '3a', '1a');
        node = tree.getNodeValue('3a');
        expect(node).to.eql('another child');
        node = tree.getNodeValue('1a');
        return expect(node).to.eql('another 1st level');
      });
    });
    describe('isAncestor', function() {
      var tree;
      tree = new taproot.Tree;
      tree.createNode('root', 'root');
      tree.createNode('1st level', '1', 'root');
      tree.createNode('2nd level', '2', '1');
      tree.createNode('3rd level', '3', '2');
      tree.createNode('another 1st level', '1a', 'root');
      tree.createNode('another child', '3a', '1a');
      it('should return true if a node is the ancestor of another node', function() {
        var expected;
        expected = tree.isAncestor('2', '3');
        expect(expected).to.be(true);
        expected = tree.isAncestor('root', '3');
        return expect(expected).to.be(true);
      });
      return it('should return false if a node is not the ancestor of another node', function() {
        var expected;
        expected = tree.isAncestor('2', '2');
        expect(expected).to.be(false);
        expected = tree.isAncestor('2', 'root');
        return expect(expected).to.be(false);
      });
    });
    describe('isChild', function() {
      var tree;
      tree = new taproot.Tree;
      tree.createNode('root', 'root');
      tree.createNode('1st level', '1', 'root');
      tree.createNode('2nd level', '2', '1');
      tree.createNode('3rd level', '3', '2');
      tree.createNode('another 1st level', '1a', 'root');
      tree.createNode('another child', '3a', '1a');
      it('should return true if a node is the direct child of another node', function() {
        var expected;
        expected = tree.isChild('3', '2');
        expect(expected).to.be(true);
        expected = tree.isChild('3a', '1a');
        return expect(expected).to.be(true);
      });
      return it('should return false if a node is not the direct child of another node', function() {
        var expected;
        expected = tree.isChild('2', '2');
        expect(expected).to.be(false);
        expected = tree.isChild('root', '2');
        expect(expected).to.be(false);
        expected = tree.isChild('3', 'root');
        return expect(expected).to.be(false);
      });
    });
    describe('isDescendant', function() {
      var tree;
      tree = new taproot.Tree;
      tree.createNode('root', 'root');
      tree.createNode('1st level', '1', 'root');
      tree.createNode('2nd level', '2', '1');
      tree.createNode('3rd level', '3', '2');
      tree.createNode('another 1st level', '1a', 'root');
      tree.createNode('another child', '3a', '1a');
      it('should return true if a node is the descendant of another node', function() {
        var expected;
        expected = tree.isDescendant('3', '2');
        expect(expected).to.be(true);
        expected = tree.isDescendant('3', 'root');
        return expect(expected).to.be(true);
      });
      return it('should return false if a node is not the descendant of another node', function() {
        var expected;
        expected = tree.isDescendant('2', '2');
        expect(expected).to.be(false);
        expected = tree.isDescendant('root', '2');
        return expect(expected).to.be(false);
      });
    });
    describe('isParent', function() {
      var tree;
      tree = new taproot.Tree;
      tree.createNode('root', 'root');
      tree.createNode('1st level', '1', 'root');
      tree.createNode('2nd level', '2', '1');
      tree.createNode('3rd level', '3', '2');
      tree.createNode('another 1st level', '1a', 'root');
      tree.createNode('another child', '3a', '1a');
      it('should return true if a node is the direct parent of another node', function() {
        var expected;
        expected = tree.isParent('2', '3');
        expect(expected).to.be(true);
        expected = tree.isParent('1a', '3a');
        return expect(expected).to.be(true);
      });
      return it('should return false if a node is not the direct parent of another node', function() {
        var expected;
        expected = tree.isParent('2', '2');
        expect(expected).to.be(false);
        expected = tree.isParent('2', 'root');
        expect(expected).to.be(false);
        expected = tree.isParent('root', '3');
        return expect(expected).to.be(false);
      });
    });
    describe('moveNode', function() {
      return it('should move a node from one position to another', function() {
        var expected, nodes, tree;
        tree = new taproot.Tree;
        tree.createNode('root', 'root');
        tree.createNode('1st level', '1', 'root');
        tree.createNode('2nd level which will be moved to 1st level', '2', '1');
        tree.createNode('3rd level', '3', '2');
        tree.createNode('another 1st level', '1a', 'root');
        tree.createNode('another child', '3a', '1a');
        tree.moveNode('2', 'root');
        nodes = tree.toObj();
        expected = {
          data: 'root',
          children: [
            {
              data: '1st level'
            }, {
              data: 'another 1st level',
              children: [
                {
                  data: 'another child'
                }
              ]
            }, {
              data: '2nd level which will be moved to 1st level',
              children: [
                {
                  data: '3rd level'
                }
              ]
            }
          ]
        };
        return expect(nodes).to.eql(expected);
      });
    });
    describe('removeNode', function() {
      it('should remove a node and all of its children when clearChildren is not set or true', function() {
        var expected, nodes, tree;
        tree = new taproot.Tree;
        tree.createNode('root', 'root');
        tree.createNode('1st level', '1', 'root');
        tree.createNode('2nd level', '2', '1');
        tree.createNode('3rd level', '3', '2');
        tree.createNode('another 1st level', '1a', 'root');
        tree.createNode('another child', '3a', '1a');
        tree.removeNode('1');
        nodes = tree.toObj();
        expected = {
          data: 'root',
          children: [
            {
              data: 'another 1st level',
              children: [
                {
                  data: 'another child'
                }
              ]
            }
          ]
        };
        return expect(nodes).to.eql(expected);
      });
      it("should remove a node and its children should become children of the removed node's parent when clearChildren is false", function() {
        var expected, nodes, tree;
        tree = new taproot.Tree;
        tree.createNode('root', 'root');
        tree.createNode('1st level', '1', 'root');
        tree.createNode('2nd level', '2', '1');
        tree.createNode('3rd level', '3', '2');
        tree.createNode('another 1st level', '1a', 'root');
        tree.createNode('another child', '3a', '1a');
        tree.removeNode('1', false);
        nodes = tree.toObj();
        expected = {
          data: 'root',
          children: [
            {
              data: 'another 1st level',
              children: [
                {
                  data: 'another child'
                }
              ]
            }, {
              data: '2nd level',
              children: [
                {
                  data: '3rd level'
                }
              ]
            }
          ]
        };
        return expect(nodes).to.eql(expected);
      });
      return it('should throw an exception when the supplied node does not exist', function() {
        var tree;
        tree = new taproot.Tree;
        tree.createNode('root', 'root');
        tree.createNode('1st level', '1', 'root');
        tree.createNode('2nd level', '2', '1');
        tree.createNode('3rd level', '3', '2');
        tree.createNode('another 1st level', '1a', 'root');
        tree.createNode('another child', '3a', '1a');
        return expect(function() {
          return tree.removeNode('dne');
        }).to.throwError();
      });
    });
    describe('reverse', function() {
      var tree;
      tree = new taproot.Tree;
      tree.createNode('root', 'root');
      tree.createNode('1st level', '1', 'root');
      tree.createNode('2nd level', '2', '1');
      tree.createNode('3rd level', '3', '2');
      tree.createNode('another 1st level', '1a', 'root');
      tree.createNode('another child', '3a', '1a');
      it('should return a list of identifiers working backwards from the supplied position', function() {
        var expected, results;
        results = tree.reverse('3a');
        expected = ['3a', '1a', 'root'];
        return expect(results).to.eql(expected);
      });
      return it('should filter the results when a filter is provided', function() {
        var expected, results;
        results = tree.reverse('3a', function(elem) {
          return elem !== 'root';
        });
        expected = ['3a', '1a'];
        return expect(results).to.eql(expected);
      });
    });
    describe('subTree', function() {
      return it('should return a subtree using the supplied position as its root', function() {
        var expected, nodes, subtree, tree;
        tree = new taproot.Tree;
        tree.createNode('root', 'root');
        tree.createNode('1st level', '1', 'root');
        tree.createNode('2nd level', '2', '1');
        tree.createNode('3rd level', '3', '2');
        tree.createNode('another 1st level', '1a', 'root');
        tree.createNode('another child', '3a', '1a');
        subtree = tree.subTree('2');
        nodes = subtree.toObj();
        expected = {
          data: '2nd level',
          children: [
            {
              data: '3rd level'
            }
          ]
        };
        return expect(nodes).to.eql(expected);
      });
    });
    describe('toObj', function() {
      var tree;
      tree = new taproot.Tree;
      tree.createNode('root', 'root');
      tree.createNode('1st level', '1', 'root');
      tree.createNode('2nd level', '2', '1');
      tree.createNode('another 1st level', '1a', 'root');
      it('should not be confined to starting from the root', function() {
        var expected, nodes;
        nodes = tree.toObj('1');
        expected = {
          data: '1st level',
          children: [
            {
              data: '2nd level'
            }
          ]
        };
        expect(nodes).to.eql(expected);
        nodes = tree.toObj('2');
        expected = {
          data: '2nd level'
        };
        return expect(nodes).to.eql(expected);
      });
      return it('should reflect supplied root and children key names', function() {
        var expected, nodes;
        nodes = tree.toObj(tree.root, 'n', 'c');
        expected = {
          n: 'root',
          c: [
            {
              n: '1st level',
              c: [
                {
                  n: '2nd level'
                }
              ]
            }, {
              n: 'another 1st level'
            }
          ]
        };
        return expect(nodes).to.eql(expected);
      });
    });
    return describe('transplant', function() {
      it('should link the root of a new tree to the supplied position', function() {
        var expected, newTree, nodes, tree;
        tree = new taproot.Tree;
        tree.createNode('root', 'root');
        tree.createNode('1st level', '1', 'root');
        tree.createNode('2nd level', '2', '1');
        newTree = new taproot.Tree;
        newTree.createNode('root', 'rootn');
        newTree.createNode('1st level new', '1n', 'rootn');
        newTree.createNode('2nd level new', '2n', '1n');
        tree.transplant('1', newTree);
        nodes = tree.toObj();
        expected = {
          data: 'root',
          children: [
            {
              data: '1st level',
              children: [
                {
                  data: '2nd level'
                }, {
                  data: 'root',
                  children: [
                    {
                      data: '1st level new',
                      children: [
                        {
                          data: '2nd level new'
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        };
        return expect(nodes).to.eql(expected);
      });
      return it('should throw an exception if there are duplicate node identifiers', function() {
        var newTree, tree;
        tree = new taproot.Tree;
        tree.createNode('root', 'root');
        tree.createNode('1st level', '1', 'root');
        tree.createNode('2nd level', '2', '1');
        newTree = new taproot.Tree;
        newTree.createNode('root', 'rootn');
        newTree.createNode('1st level new', '1n', 'rootn');
        newTree.createNode('2nd level new', '2', '1n');
        return expect(function() {
          return tree.transplant('1', newTree);
        }).to.throwError();
      });
    });
  });

  describe('Node', function() {
    describe('generateUUID', function() {
      it('should generate a UUID', function() {
        var node, uuid;
        node = new taproot.Node;
        uuid = node.generateUUID();
        return expect(uuid.length).to.be(36);
      });
      return it('should be unique', function() {
        var node, uuid1, uuid2, uuid3;
        node = new taproot.Node;
        uuid1 = node.generateUUID();
        uuid2 = node.generateUUID();
        uuid3 = node.generateUUID();
        expect(uuid1).to.not.equal(uuid2);
        expect(uuid2).to.not.equal(uuid3);
        return expect(uuid1).to.not.equal(uuid3);
      });
    });
    return describe('updateFPointer', function() {
      it('should add an identifier when the mode is ADD', function() {
        var node;
        node = new taproot.Node;
        expect(node.fPointer).to.be.empty();
        node.updateFPointer('test');
        expect(node.fPointer).to.be.eql(['test']);
        node.updateFPointer('test-again');
        return expect(node.fPointer).to.be.eql(['test', 'test-again']);
      });
      it('should remove an identifier when the mode is DELETE', function() {
        var node;
        node = new taproot.Node;
        node.updateFPointer('test');
        node.updateFPointer('test-again');
        expect(node.fPointer).to.be.eql(['test', 'test-again']);
        node.updateFPointer('test-again', 'DELETE');
        expect(node.fPointer).to.be.eql(['test']);
        node.updateFPointer('test', 'DELETE');
        return expect(node.fPointer).to.be.empty();
      });
      return it('should replace its contents when the mode is REPLACE', function() {
        var node;
        node = new taproot.Node;
        node.updateFPointer('test');
        node.updateFPointer('test-again');
        node.updateFPointer('test-me', 'REPLACE');
        return expect(node.fPointer).to.be.eql(['test-me']);
      });
    });
  });

}).call(this);
