expect = require 'expect.js'
taproot = require '../lib/taproot'

describe 'Tree', ->
  describe 'createNode', ->
    it 'should create a properly nested node within the tree', ->
      tree = new taproot.Tree
      tree.createNode 'root', 'root'
      tree.createNode '1st level', '1', 'root'
      tree.createNode '2nd level', '2', '1'
      tree.createNode 'another 1st level', '1a', 'root'
      nodes = tree.toObj()
      expected =
        data: 'root'
        children: [
          {
            data: '1st level'
            children: [{
              data: '2nd level'
            }]
          },
          {
            data: 'another 1st level'
          }
        ]
      expect(nodes).to.eql expected

    it 'should not allow multiple root nodes', ->
      tree = new taproot.Tree
      tree.createNode()
      expect(-> tree.createNode()).to.throwError()

    it 'should preserve arbitrary values', ->
      tree = new taproot.Tree
      tree.createNode {test: 'me', please: 'ok'}, 'root'
      tree.createNode {also: 'this', check: [1, 3]}, '1st level', 'root'
      nodes = tree.toObj(tree.root, 'data')
      expected =
        data: {test: 'me', please: 'ok'}
        children: [
          {
            data: {also: 'this', check: [1, 3]}
          }
        ]
      expect(nodes).to.eql expected

  describe 'expand', ->
    tree = new taproot.Tree
    tree.createNode 'root', 'root'
    tree.createNode '1st level', '1', 'root'
    tree.createNode '2nd level', '2', '1'
    tree.createNode '3rd level', '3', '2'
    tree.createNode 'another 1st level', '1a', 'root'
    tree.createNode 'another child', '3a', '1a'

    it 'should return a list of identifiers in depth order when mode is DEPTH', ->
      expansion = tree.expand()
      expected = ['root', '1', '2', '3', '1a', '3a']
      expect(expansion).to.eql expected
    it 'should return a list of identifiers in width order when mode is WIDTH', ->
      expansion = tree.expand tree.root, 'WIDTH'
      expected = ['root', '1', '1a', '2', '3a', '3']
      expect(expansion).to.eql expected
    it 'should filter the results when a filter is provided', ->
      expansion = tree.expand tree.root, 'DEPTH', (elem) ->
        elem isnt 'root'
      expect(expansion).to.be.empty()

  describe 'getNodeLevel', ->
    it 'should return the level of the specified node:', ->
      tree = new taproot.Tree
      tree.createNode 'root', 'root'
      tree.createNode '1st level', '1', 'root'
      tree.createNode '2nd level', '2', '1'
      tree.createNode '3rd level', '3', '2'
      tree.createNode 'another 1st level', '1a', 'root'
      tree.createNode 'another child', '3a', '1a'

      node = tree.getNodeLevel '3a'
      expect(node).to.eql 2

      node = tree.getNodeLevel 'root'
      expect(node).to.eql 0

      node = tree.getNodeLevel '3'
      expect(node).to.eql 3

      node = tree.getNodeLevel '1'
      expect(node).to.eql 1

      node = tree.getNodeLevel '1a'
      expect(node).to.eql 1

  describe 'getNodeValue', ->
    it 'should return the value of the specified node:', ->
      tree = new taproot.Tree
      tree.createNode 'root', 'root'
      tree.createNode '1st level', '1', 'root'
      tree.createNode '2nd level', '2', '1'
      tree.createNode '3rd level', '3', '2'
      tree.createNode 'another 1st level', '1a', 'root'
      tree.createNode 'another child', '3a', '1a'

      node = tree.getNodeValue '3a'
      expect(node).to.eql 'another child'

      node = tree.getNodeValue '1a'
      expect(node).to.eql 'another 1st level'

  describe 'isAncestor', ->
    tree = new taproot.Tree
    tree.createNode 'root', 'root'
    tree.createNode '1st level', '1', 'root'
    tree.createNode '2nd level', '2', '1'
    tree.createNode '3rd level', '3', '2'
    tree.createNode 'another 1st level', '1a', 'root'
    tree.createNode 'another child', '3a', '1a'

    it 'should return true if a node is the ancestor of another node', ->
      expected = tree.isAncestor '2', '3'
      expect(expected).to.be true

      expected = tree.isAncestor 'root', '3'
      expect(expected).to.be true

    it 'should return false if a node is not the ancestor of another node', ->
      expected = tree.isAncestor '2', '2'
      expect(expected).to.be false

      expected = tree.isAncestor '2', 'root'
      expect(expected).to.be false

  describe 'isChild', ->
    tree = new taproot.Tree
    tree.createNode 'root', 'root'
    tree.createNode '1st level', '1', 'root'
    tree.createNode '2nd level', '2', '1'
    tree.createNode '3rd level', '3', '2'
    tree.createNode 'another 1st level', '1a', 'root'
    tree.createNode 'another child', '3a', '1a'

    it 'should return true if a node is the direct child of another node', ->
      expected = tree.isChild '3', '2'
      expect(expected).to.be true

      expected = tree.isChild '3a', '1a'
      expect(expected).to.be true

    it 'should return false if a node is not the direct child of another node', ->
      expected = tree.isChild '2', '2'
      expect(expected).to.be false

      expected = tree.isChild 'root', '2'
      expect(expected).to.be false

      expected = tree.isChild '3', 'root'
      expect(expected).to.be false

  describe 'isDescendant', ->
    tree = new taproot.Tree
    tree.createNode 'root', 'root'
    tree.createNode '1st level', '1', 'root'
    tree.createNode '2nd level', '2', '1'
    tree.createNode '3rd level', '3', '2'
    tree.createNode 'another 1st level', '1a', 'root'
    tree.createNode 'another child', '3a', '1a'

    it 'should return true if a node is the descendant of another node', ->
      expected = tree.isDescendant '3', '2'
      expect(expected).to.be true

      expected = tree.isDescendant '3', 'root'
      expect(expected).to.be true

    it 'should return false if a node is not the descendant of another node', ->
      expected = tree.isDescendant '2', '2'
      expect(expected).to.be false

      expected = tree.isDescendant 'root', '2'
      expect(expected).to.be false

  describe 'isParent', ->
    tree = new taproot.Tree
    tree.createNode 'root', 'root'
    tree.createNode '1st level', '1', 'root'
    tree.createNode '2nd level', '2', '1'
    tree.createNode '3rd level', '3', '2'
    tree.createNode 'another 1st level', '1a', 'root'
    tree.createNode 'another child', '3a', '1a'

    it 'should return true if a node is the direct parent of another node', ->
      expected = tree.isParent '2', '3'
      expect(expected).to.be true

      expected = tree.isParent '1a', '3a'
      expect(expected).to.be true

    it 'should return false if a node is not the direct parent of another node', ->
      expected = tree.isParent '2', '2'
      expect(expected).to.be false

      expected = tree.isParent '2', 'root'
      expect(expected).to.be false

      expected = tree.isParent 'root', '3'
      expect(expected).to.be false

  describe 'moveNode', ->
    it 'should move a node from one position to another', ->
      tree = new taproot.Tree
      tree.createNode 'root', 'root'
      tree.createNode '1st level', '1', 'root'
      tree.createNode '2nd level which will be moved to 1st level', '2', '1'
      tree.createNode '3rd level', '3', '2'
      tree.createNode 'another 1st level', '1a', 'root'
      tree.createNode 'another child', '3a', '1a'

      tree.moveNode '2', 'root'
      nodes = tree.toObj()
      expected =
        data: 'root'
        children: [
          {
            data: '1st level'
          },
          {
            data: 'another 1st level'
            children: [
              data: 'another child'
            ]
          }
          {
            data: '2nd level which will be moved to 1st level',
            children: [
              data: '3rd level'
            ]
          },
        ]
      expect(nodes).to.eql expected

  describe 'removeNode', ->
    it 'should remove a node and all of its children when clearChildren is not set or true', ->
      tree = new taproot.Tree
      tree.createNode 'root', 'root'
      tree.createNode '1st level', '1', 'root'
      tree.createNode '2nd level', '2', '1'
      tree.createNode '3rd level', '3', '2'
      tree.createNode 'another 1st level', '1a', 'root'
      tree.createNode 'another child', '3a', '1a'

      tree.removeNode('1')
      nodes = tree.toObj()
      expected =
        data: 'root'
        children: [
          {
            data: 'another 1st level',
            children: [
              {
                data: 'another child'
              }
            ]
          }
        ]
      expect(nodes).to.eql expected

    it "should remove a node and its children should become children of the removed node's parent when clearChildren is false", ->
      tree = new taproot.Tree
      tree.createNode 'root', 'root'
      tree.createNode '1st level', '1', 'root'
      tree.createNode '2nd level', '2', '1'
      tree.createNode '3rd level', '3', '2'
      tree.createNode 'another 1st level', '1a', 'root'
      tree.createNode 'another child', '3a', '1a'

      tree.removeNode('1', false)
      nodes = tree.toObj()
      expected =
        data: 'root'
        children: [
          {
            data: 'another 1st level',
            children: [
              {
                data: 'another child'
              }
            ]
          },
          {
            data: '2nd level',
            children: [
              {
                data: '3rd level'
              }
            ]
          }
        ]
      expect(nodes).to.eql expected

    it 'should throw an exception when the supplied node does not exist', ->
      tree = new taproot.Tree
      tree.createNode 'root', 'root'
      tree.createNode '1st level', '1', 'root'
      tree.createNode '2nd level', '2', '1'
      tree.createNode '3rd level', '3', '2'
      tree.createNode 'another 1st level', '1a', 'root'
      tree.createNode 'another child', '3a', '1a'

      expect(-> tree.removeNode('dne')).to.throwError()

  describe 'reverse', ->
    tree = new taproot.Tree
    tree.createNode 'root', 'root'
    tree.createNode '1st level', '1', 'root'
    tree.createNode '2nd level', '2', '1'
    tree.createNode '3rd level', '3', '2'
    tree.createNode 'another 1st level', '1a', 'root'
    tree.createNode 'another child', '3a', '1a'

    it 'should return a list of identifiers working backwards from the supplied position', ->
      results = tree.reverse '3a'
      expected = ['3a', '1a', 'root']
      expect(results).to.eql expected
    it 'should filter the results when a filter is provided', ->
      results = tree.reverse '3a', (elem) ->
        elem isnt 'root'
      expected = ['3a', '1a']
      expect(results).to.eql(expected)

  describe 'subTree', ->
    it 'should return a subtree using the supplied position as its root', ->
      tree = new taproot.Tree
      tree.createNode 'root', 'root'
      tree.createNode '1st level', '1', 'root'
      tree.createNode '2nd level', '2', '1'
      tree.createNode '3rd level', '3', '2'
      tree.createNode 'another 1st level', '1a', 'root'
      tree.createNode 'another child', '3a', '1a'

      subtree = tree.subTree '2'
      nodes = subtree.toObj()
      expected =
        data: '2nd level'
        children: [
          {
            data: '3rd level'
          }
        ]
      expect(nodes).to.eql expected

  describe 'toObj', ->
    tree = new taproot.Tree
    tree.createNode 'root', 'root'
    tree.createNode '1st level', '1', 'root'
    tree.createNode '2nd level', '2', '1'
    tree.createNode 'another 1st level', '1a', 'root'

    it 'should not be confined to starting from the root', ->
      nodes = tree.toObj '1'
      expected = {
        data: '1st level'
        children: [
          data: '2nd level'
        ]
      }
      expect(nodes).to.eql expected

      nodes = tree.toObj '2'
      expected = {
        data: '2nd level'
      }
      expect(nodes).to.eql expected

    it 'should reflect supplied root and children key names', ->
      nodes = tree.toObj tree.root, 'n', 'c'
      expected = {
        n: 'root'
        c: [
          {
            n: '1st level'
            c: [{
              n: '2nd level'
            }]
          },
          {
            n: 'another 1st level'
          }
        ]
      }
      expect(nodes).to.eql expected

  describe 'transplant', ->
    it 'should link the root of a new tree to the supplied position', ->
      tree = new taproot.Tree
      tree.createNode 'root', 'root'
      tree.createNode '1st level', '1', 'root'
      tree.createNode '2nd level', '2', '1'

      newTree = new taproot.Tree
      newTree.createNode 'root', 'rootn'
      newTree.createNode '1st level new', '1n', 'rootn'
      newTree.createNode '2nd level new', '2n', '1n'

      tree.transplant '1', newTree

      nodes = tree.toObj()
      expected = {
        data: 'root'
        children: [
          {
            data: '1st level'
            children: [
              {
                data: '2nd level'
              },
              {
                data: 'root'
                children: [
                  {
                    data: '1st level new'
                    children: [
                      {
                        data: '2nd level new'
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
      expect(nodes).to.eql expected

    it 'should throw an exception if there are duplicate node identifiers', ->
      tree = new taproot.Tree
      tree.createNode 'root', 'root'
      tree.createNode '1st level', '1', 'root'
      tree.createNode '2nd level', '2', '1'

      newTree = new taproot.Tree
      newTree.createNode 'root', 'rootn'
      newTree.createNode '1st level new', '1n', 'rootn'
      # Duplicate here
      newTree.createNode '2nd level new', '2', '1n'

      expect(-> tree.transplant '1', newTree).to.throwError()

describe 'Node', ->
  describe 'generateUUID', ->
    it 'should generate a UUID', ->
      node = new taproot.Node
      uuid = node.generateUUID()
      expect(uuid.length).to.be 36
    it 'should be unique', ->
      node = new taproot.Node
      uuid1 = node.generateUUID()
      uuid2 = node.generateUUID()
      uuid3 = node.generateUUID()
      expect(uuid1).to.not.equal uuid2
      expect(uuid2).to.not.equal uuid3
      expect(uuid1).to.not.equal uuid3

  describe 'updateFPointer', ->
    it 'should add an identifier when the mode is ADD', ->
      node = new taproot.Node
      expect(node.fPointer).to.be.empty()
      # default mode is 'ADD'
      node.updateFPointer('test')
      expect(node.fPointer).to.be.eql(['test'])
      node.updateFPointer('test-again')
      expect(node.fPointer).to.be.eql(['test', 'test-again'])
    it 'should remove an identifier when the mode is DELETE', ->
      node = new taproot.Node
      node.updateFPointer('test')
      node.updateFPointer('test-again')
      expect(node.fPointer).to.be.eql(['test', 'test-again'])
      node.updateFPointer('test-again', 'DELETE')
      expect(node.fPointer).to.be.eql(['test'])
      node.updateFPointer('test', 'DELETE')
      expect(node.fPointer).to.be.empty()
    it 'should replace its contents when the mode is REPLACE', ->
      node = new taproot.Node
      node.updateFPointer('test')
      node.updateFPointer('test-again')
      node.updateFPointer('test-me', 'REPLACE')
      expect(node.fPointer).to.be.eql(['test-me'])
